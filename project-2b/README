NAME: Neil Sonnenberg
EMAIL: sonnenbergneil@gmail.com
ID: 204748664

2.3.1 Cycles in the basic list implementation:
A: During the 1 and 2 thread list runs, most of the cycles can be contributed to
the critical sections of the list operations.

A: These are the most intensive since they require large iterations to be executed serially
without parallelism, not to mention the insert function requires iterating the existing list 
for a spot to place the item.

A: As thread count increases in the spin lock, more and more time is spent in context switches 
and spinning while waiting for a lock. 

A: In the mutex lock time is also spent in context switches but also in making system calls to
put the threads to sleep so they don't spin.


2.3.2 Execution Profiling:
A: The __sync_lock_test_and_set instruction ended up consuming the most cycles in the list exerciser.

A: This operation became so expensive because it implements the spin lock and is run by a thread
without a lock until it gets a lock. It is basically the operation that is run while a thread
is spinning which made it consume the most cycles


2.3.3 Mutex Wait Time
A: The lock-wait time rises dramatically with number of threads since with more threads
there is more chance of lock contention and more time spent in lock contention since
there are simply more threads competing for the lock.

A: Overall completion time rises less dramatically because there is at least always one
thread making progress so it does not get affected by lock wait time.

A: The wait time per operation is able to go up faster an dhigher than the completion
time per operation because each thread has its own lock when waiting for the lock.

A: Since many threads can be waiting at the same time, their times can overlapped and be added
together which creates a perceived dramatic growth. The time per operation only relies on a
single clock and thus does not need to worry about overlapped time.


2.3.4
A: As the number of lists increases, the throughput increases.

A: Eventually the throughput will hit a limit as at some point there will be as many lists
as there are elements and any more lists from that will not improve performance.

A: Unfortunately, in real-world conditions, we cannot guarantee that there is an even 
distribution between lists and element and threads thus it is not reasonable to suggest
them to be equivalent


Contents:
SortedList.h 	a header file containing interfaces for linked list operations

SortedList.c 	the source for a C source module that implements the methods outlined in SortedList.h

lab2_list.c 	the source for a C program that implements specified command line options: --threads,
				--iterations, --yield, --sync, --lists. It drives one or more parallel threads to do 
				operations on a shared linked list.

Makefile		a Makefile to build the deliverable programs, output, graphs, and tarball. It has targets:
					* default: compiles lab2_list executable
					* tests: runs all the specified test cases to generate CSV results
					* profile: runs tests with profiling tools to generate an execution profiling report
					* graphs: uses gnuplot to generate required graphs
					* dists: creates the deliverable tarball
					* clean: deletes all programs and output generated by the Makefile

lab2b_list.csv 	contains the results for all test runs made by make tests

profile.out 	execution profiling report showing where time was spent in the un-partitioned spin-lock
				implementation

lab2b_1.png 	graphs throughput vs. number of threads for mutex and spin-lock synchronized list operations

lab2b_2.png 	graphs mean time per mutex wait and mean time per operation for mutex-synchronized list
				operations

lab2b_3.png 	graphs successful iterations vs. threads for each synchronization method

lab2b_4.png 	graphs throughput vs. number of threads for mutex synchronized partitioned lists

lab2b_5.png 	graphs throughput vs. number of threads for spin-lock-synchronized partitioned lists

test.sh 		a bash script that runs all the specified test cases in the project specification

lab2b_list.gp 	a script for creating the gnuplot graphs

README 			contains brief answers to the questions posed in the project specification as well as
				descriptions of each of the included files


NOTE FOR GRADER: 
I talked to Jonathan Lin about this issue but sometimes my project does not pass the optimization
check in the sanity check provided. However, he contributed this to variability in testing as it
does pass most of the time and fails sometimes. He said that this was good enough for submission.